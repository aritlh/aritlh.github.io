{"pages":[{"title":"About","date":"2016-10-24T03:24:00.000Z","path":"about/index.html","text":"关于我自己Hello, my name is Muhammad Faqih Alharits, or commonly called Ari (on campus). I’m a proper coding fanatic, mate. Can’t get enough of that programming malarkey. One thing that really gets me going is ethical hacking - finding security holes and plugging them up before any dodgy blokes try to exploit the system, y’know? but i still newbie forever. As for coding languages, JavaScript and TypeScript are right up my street. JS is the main lingo for web development, and TypeScript builds on it with some fancy object-oriented stuff and static type checking. Smashing, that is. I’ve also got a bit of Python under my belt, even though I’m not an expert or anything. Dead handy language for data analysis, web apps, AI, you name it. And then there’s Rust - a systems programming language that’s bloody brilliant when it comes to security and performance. Ideal for operating systems, device drivers, low-level system apps and the like. I’m well chuffed to keep learning and trying out new tech. Coding’s my passion, innit? Hopefully, I can make a decent contribution to the programming world and keep the cyber security lot on their toes."},{"title":"Categories","date":"2024-04-15T07:00:05.974Z","path":"categories/index.html","text":""}],"posts":[{"title":"VueJS #6 Lifecycle Hooks","date":"2024-04-16T13:00:21.000Z","path":"wiki/Programming/VueJS/lifecycle-hooks/","text":"Each Vue component instance goes through a series of initialization steps when it’s created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their code at specific stages. Registering Lifecycle HooksFor example, the mounted hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:​ 12345export default { mounted() { console.log(`the component is now mounted.`) } } There are also other hooks which will be called at different stages of the instance’s lifecycle, with the most commonly used being mounted, updated, and unmounted. All lifecycle hooks are called with their this context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won’t be able to access the component instance via this if you do so. If our project uses the Options API, we don’t have to change any of the code for our Vue lifecycle hooks. This is because Vue 3 is designed to be compatible with prior releases of Vue. However, the way we access these hooks is a little bit different when we decide to use the Composition API - which is especially useful in larger Vue projects. By the end of this article, hope you’ll know how to use lifecycle hooks in both the Options API and Composition API and be on your way to writing better code. Lifecycle DiagramBelow is a diagram for the instance lifecycle. You don’t need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference. Open The Diagram Essentially, each main Vue lifecycle event is separated into two hooks that are called right before that event and then right after. There are four main events (8 main hooks) that you can utilize in your Vue app. Creation - runs on your component’s creation Mounting - runs when the DOM is mounted. Updates - runs when reactive data is modified. Destruction - runs right before your element is destroyed. Using our Vue Lifecycle Hooks in the Options APIWith the Options API, our lifecycle hooks are exposed as options on our Vue instance. We don’t need to import anything, just invoke the method and write the code for that. For example, let’s say we wanted to access our mounted() and our update() lifecycle hooks. It might look something like this. 12345678910&lt;script&gt; export default { mounted() { console.log(&#39;mounted!&#39;) }, updated() { console.log(&#39;updated!&#39;) }, } &lt;/script&gt; See details Options API Lifecycle Hooks. Using our Vue Lifecycle Hooks in the Vue Composition API Usage Note All APIs listed on this page must be called synchronously during the setup() phase of a component. See Guide - Lifecycle Hooks for more details. In the Composition API, we’ve to import lifecycle hooks into our project before we can use them. This is to help keep projects as lightweight as possible. 1import { onMounted } from &#39;vue&#39; Excluding beforeCreate() and created() (which are replaced by the setup() method itself), there are 12 of the Options API lifecycle host that we can access in our setup method. See details Composition API Lifecycle Hooks. When we import them and access them in our code, it would look like this. 1234567891011&lt;script&gt; import { onMounted } from &#39;vue&#39; export default { setup() { onMounted(() =&gt; { console.log(&#39;mounted in the composition api!&#39;) }) }, } &lt;/script&gt; An In-Depth Look at Each Lifecycle HookWe now understand two important things: The different lifecycle hooks we can use How to use them in both the Options API and the Composition API Let’s take a deeper dive at each lifecycle hook and look at how they’re used, what kind of code we can write in each one, and the differences between them in the Options API and Composition API. Creation Hooks - The Start of the VueJS LifecycleCreation hooks are they very first thing that runs in program. beforeCreate() - Options APISince the craeted hook is the thing that initializes all of the reactive data and events, beforeCreate() doesn’t have access to any of a component’s reactive data and events. 1234567891011121314&lt;script&gt; export default { data() { return { val: &quot;Hello&quot; } }, beforeCreate() { console.log(`Value of val is: ${this.val}`) } } &lt;/script&gt; &lt;template&gt;&lt;/template&gt; The output value of val is undefined ‘cause data hasn’t been initialized yet. You also can’t call your component methods in this method either: If you wanna see a full list of what is available, I’d recommend just running console.log(this) to see what has been initialized. This is useful in every hook too using the Options API. created() - Options APIWe now have access to the component’s data and events. So modifying the example from above to use created() instead beforeCreate() we see how the output changes. 1234567891011121314&lt;script&gt; export default { data() { return { val: &quot;Hello&quot; } }, created() { console.log(`Value of val is: ${this.val}`) } } &lt;/script&gt; &lt;template&gt;&lt;/template&gt; The output of this would be Value of val is: hello because we have initialized our data. Using the created method is useful when dealing with reading&#x2F;writing the reactive data. For example, if you want to make an API call and then store that value, this is the place to do it. It’s better to do that here than in mounted because it happens earlier in Vue’s synchronous initialization process and you perform data reading&#x2F;writing all you want. What about the Composition API Creation Hooks?For the Vue 3 Lifecycle Hooks using the Composition API, both beforeCreate() and created() are replaced by the setup() method. This means that any code you would have put inside either of these methods is now just inside your setup method. 1234567891011121314&lt;script&gt; import { ref } from &#39;vue&#39; export default { setup() { const val = ref(&#39;hello this is composition API&#39;) console.log(&#39;Value of val is: &#39; + val.value) return { val, } }, } &lt;/script&gt; &lt;template&gt;&lt;/template&gt; Mounting Hooks – Accessing the DOMThese mounting hooks handle mounting and rendering the component. These are some of the most commonly used hooks in projects and applications. beforeMount() and onBeforeMount()Registers a hook to be called right before the component is to be mounted. Options API beforeMount() Type 123interface ComponentOptions { beforeMount?(this: ComponentPublicInstance): void } Details When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering. Example 12345export default { beforeMount() { console.log(this.$el) }, } Composition API onBeforeMount() Type 1function onBeforeMount(callback: () =&gt; void): void Details When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering. Example 12345678910111213141516171819202122&lt;template&gt; &lt;div ref=&quot;root&quot;&gt;Hello World&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, onBeforeMount } from &#39;vue&#39; export default { setup() { const root = ref(null) onBeforeMount(() =&gt; { console.log(root.value) }) return { root, } }, beforeMount() { console.log(this.$el) }, } &lt;/script&gt; Then, the corresponding script to try and access the ref. Since, app.$el isn’t yet created, the output will be undefined. While it’s preferred that you use created()&#x2F;setup() to perform your API calls, this is really the last step you should call them before it’s unnecessary late in the process because it’s right after created — they have access to the same component variables. mounted() and onMounted()Register a callback to be called after the component has been mounted Options API mounted() Type 123interface ComponentOptions { mounted?(this: ComponentPublicInstance): void } Details A component is considered mounted after: All of its synchronous child components have been mounted (does not include async components or components inside &lt;Suspense&gt; trees). Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component’s DOM tree is in-document if the application’s root container is also in-document. This hook is typically used for performing side effects that need access to the component’s rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering. Example 12345export default { mounted() { console.log(this.$el) }, } Composition API onMounted() Details A component is considered mounted after: All of its synchronous child components have been mounted (does not include async components or components inside &lt;Suspense&gt; trees). Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component’s DOM tree is in-document if the application’s root container is also in-document. This hook is typically used for performing side effects that need access to the component’s rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering. Example 123456789101112131415161718192021&lt;script&gt; import { ref, onMounted } from &#39;vue&#39; export default { setup() { /* Composition API */ const root = ref(null) onMounted(() =&gt; { console.log(root.value) }) return { root, } }, } &lt;/script&gt; &lt;template&gt;&lt;/template&gt; Update Hooks – Reactivity in the VueJS LifecycleThe updated lifecycle event is triggered whenever reactive data is modified, triggering a render update. beforeUpdate() and onBeforeUpdate()Register a hook to be called right before the component is about to update it’s DOM tree due to a reactive state change. Options API beforeUpdate() Type 123interface ComponentOptions { beforeUpdate?(this: ComponentPublicInstance): void } Details This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook is not called during server-side rendering. Example 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ message }}&lt;/h1&gt; &lt;button @click=&quot;updateMessage&quot;&gt;Update Message&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { message: &#39;Hello, World!&#39; } }, methods: { updateMessage() { this.message = &#39;Message Updated!&#39; } }, beforeUpdate() { console.log(&#39;Component will update!&#39;) } } &lt;/script&gt; beforeUpdate() could be useful for tracking the number of edits made to a component or even tracking the actions to create an “undo” feature. Composition API onBeforeUpdate() Type 1function onBeforeUpdate(callback: () =&gt; void): void Details This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook isn’t called during server-side rendering. Example 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ message }}&lt;/h1&gt; &lt;button @click=&quot;updateMessage&quot;&gt;Update Message&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, onBeforeUpdate } from &#39;vue&#39; export default { setup() { const message = ref(&#39;Hello, World!&#39;) const updateMessage = () =&gt; { message.value = &#39;Message Updated!&#39; } onBeforeUpdate(() =&gt; { console.log(&#39;Component will update!&#39;) }) return { message, updateMessage } } } &lt;/script&gt; These methods are useful, but for a lot of use cases we may want to consider using watchers to detect these data changes instead. Watchers are good because they give the old value and the new value of the changed data. Another option is using computed values to change the state based on elements. update() and onUpdate()Progress …","tags":[],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://aritlh.github.io/categories/Programming/"},{"name":"VueJS","slug":"Programming/VueJS","permalink":"http://aritlh.github.io/categories/Programming/VueJS/"}]},{"title":"VueJS #5 Conditional Rendering","date":"2024-04-16T11:22:21.000Z","path":"wiki/Programming/VueJS/conditional-rendering /","text":"v-ifThe directive v-if is used to conditionally render a block. The block will only be rendered if the directive’s expression returns a truthy value. 1&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; v-elseYou can use the v-else directive to indicate an “else block” for v-if: 1234&lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt; A v-else element must immediately follow a v-if or a v-else-if element otherwise it will not be recognized. v-else-ifThe v-else-if, as the name suggests, serves as an “else if block” for v-if. It can also be chained multiple times: 123456789101112&lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt; Similar to v-else, a v-else-if element must immediately follow a v-if or a v-else-if element. v-if on &lt;template&gt;Because v-if is a directive, it has to be attached to a single element. But what if we wanna toggle more than one element? In this case we can use v-if on a &lt;template&gt; element, which serves as an invisible wrapper. The final rendered result will not include the &lt;template&gt; element. 12345&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/template&gt; v-else and v-else-if can also be used on &lt;template&gt;. v-showAnother option for conditionally displaying an element is the v-show directive. The usage is largely the same: 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; The difference is that an element with v-show will always be rendered and remain in the DOM; v-show only toggles the display CSS property of the element. v-show doesn’t support the &lt;template&gt; element, nor does it work with v-else. v-if vs. v-show​v-if is “real” conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles. v-if is also lazy: if the condition is false on initial render, it will not do anything - the conditional block won’t be rendered until the condition becomes true for the first time. In comparison, v-show is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling. Generally speaking, v-if has higher toggle costs while v-show has higher initial render costs. So prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime. v-if with v-for Note It’s not recommended to use v-if and v-for on the same element due to implicit precedence. Refer to style guide for details. When v-if and v-for are both used on the same element, v-if will be evaluated first. See the list rendering guide for details.","tags":[],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://aritlh.github.io/categories/Programming/"},{"name":"VueJS","slug":"Programming/VueJS","permalink":"http://aritlh.github.io/categories/Programming/VueJS/"}]},{"title":"Network Security #3 Data Encapsulation","date":"2024-04-16T05:57:13.000Z","path":"wiki/Network Security/data-encapsulation/","text":"Each layer in the IPS is built on the one below, and each layer is able to encapsulate the data from the layer above so it can move between the layers. Data transmitted by each layer is called a protocol data unit (PDU). Headers, Footers, and AddressesThe PDU in each layer contains the payload data that is being transmitted. It’s commont to prefix a header–which contains information required for the payload data to be transmitted, such as the addresses of the source and destination nodes on the network–to the payload data. Sometimes a PDU also has a footer that is suffixed to the payload data and contains values needed to ensure correct transmission, such as error-checking information. Figure below shows how the PDUs are laid out in the IPS. The TCP header contains a source destination port number ➊. These port numbers allow a single node to have multiple unique network connections. Port numbers for TCP (and UDP) range from 0 to 65535. Most port numbers are assigned as needed to new connections, but some numbers have been given special assignments, such as poort 80 for HTTP. (You can find a current list of assigned port numbers in the /etc/services file on most Unix-like OS.) A TCP payload and header are commonly called segment, whereas a UDP payload and header are commonly called a datagram. The IP protocol uses a source and a destination address ➋. The destination address allows the data to be sent to a specific node on the network. The source address allows the receiver of the data to know which node sent the data and allows the receiver to reply to the sender. IPv4 uses 32-bit addresses, which you’ll typically ssee written as four number separated by dots, such as 192.168.10.1. IPv6 uses 128-bit addresses, because 32-bit addresses aren’t sufficient for the number of nodes on modern networks. IPv6 addresses are usually written as hexadecimal numbers separated by colons, such as fe80:0000:0000:0000:897b:581e:44b0:2057. Long strings of 0000 numbers are collapsed into two colons. For example, the preceding IPv6 address can also be written as fe80::897b:581e:44b0:2057. An IP payload and header are commonly called a packet. Ethernet also contains source and destination addresses ➌. Ethernet uses a 64-bit value called a Media Access Control (MAC) address, which is typically set during manufacture of the Ethernet adapter. You’ll usually see MAC addresses written as a series of hexadecimal numbers separated by dashes or colons, such as 0A-00-27-00-00-0E. The Ethernet payload, including the header and footer, is commonly referred to as a frame.","tags":[],"categories":[{"name":"Network Security","slug":"Network-Security","permalink":"http://aritlh.github.io/categories/Network-Security/"}]},{"title":"Network Security #2 The Internet Protocol Suite","date":"2024-04-16T05:21:13.000Z","path":"wiki/Network Security/the-internet-protocol-suite/","text":"TCP&#x2F;IP is the de facto protocol that modern networks use. Although you can think of TCP&#x2F;IP as a single protocol, it’s actually a combination of two protocols: the Transmission Control Protocol (TCP) and the Internet Protocol (IP). These two protocols form part of the Internet Protocol Suite (IPS), a conceptual model of how network protocols send network traffic over the internet that breaks down network communication into four layers. These four layers form a protocol stack. The following list explains each layer of the IPS: Link layer (layer 1) This layer is the lowest level and describes the physical mechanisms used to transfer information between nodes on a local network. Well-known examples include Ethernet (both wired and wireless) and Point-to-Point Protocol (PPP) Internet layer (layer 2) This layer provides the mechanisms for addressing network nodes. Unlike in layer 1, the nodes don’t have to be located on the local network. This level contains the IP; on modern networks, the actual protocol used could be either version 4 (IPv4) or version 6 (IPv6). Transport layer (layer 3) This layer is responsible for connections between clients and servers, sometimes ensuring the correct order of packets and providing service multiplexing. Service multiplexing allows a single node to support multiple different services by assigning a different number for each service; this number is called a port. TCP and the User Datagram Protocol (UDP) operate on this layer. Application layer (layer 4) This layer contains network protocols, such as the HyperText Transport Protocol (HTTP), which transfers web page contents; the Simple Mail Transport Protocol (SMTP), which transfers email; and the Domain Name System (DNS) protocol, which converts a name to a node on the network. Each layer interacts only with the layer above and below it, but there must be some external interactions with the stack. The link layer interacts with a physical network connection, transmitting data in a physical medium, such as pulses of electricity or light. The application layer interacts with the user application: an application is a collection of related functionality that provides a service to a user. Figure above shows an example of an application that processes email. The service provided by the mail application is the sending and receiving of messages over a network. Typically, applications contain the following components: Network communication This component communicates over the network and processes incoming and outgoing data. For a mail application, the network communication is most likely a standard protocol, such as SMTP or POP3 Content parsers Data transferred over a network usually contains content that must be extracted and processed. Content might include textual data, such as the body of an email, or it might be pictures or video. User interface (UI) The UI allows the user to view received emails and to create new emails for transmission. In a mail application, the UI might display emails using HTML in a web browser. Note the user interacting with the UI doesn’t have to be a human being. It could be another application that automates the sending and receiving of emails through a command line tool.","tags":[],"categories":[{"name":"Network Security","slug":"Network-Security","permalink":"http://aritlh.github.io/categories/Network-Security/"}]},{"title":"Network Security #1 Network Architecture and Protocols","date":"2024-04-16T01:42:21.000Z","path":"wiki/Network Security/network-architecture-and-protocols/","text":"To attack network protocols, you need to understand the basic of computer networking. The more you understand how common networks are built and function, the easier it will be to apply that knowledge to capturing, analyzing, and exploiting new protocols. Let’s start by reviewing some basic networking terminology and asking the fundamental question: “what is a network?” A network is a set of two or more computers connected together to share information. It’s common to refer to each connected device as a node on the network to make the description applicalble to a wider range of devices. The figure shows three nodes connected with a common network. Each node might have a different operating system or hardware. But as long as each node follows a set of rules, or network protocol, it can communicate with the other nodes one the network. To communicate correctly, all nodes on a network must understand the the same network protocol. A network protocol serves many functions, including one or more of the following: Maintaining session state Protocols typically implement mechanisms to create new connections and terminate existing connections. Identifying nodes through addressing Data must be transmitted to the correct node on a network. Some protocols implement an addressing mechanism to identify specific nodes or groups of nodes. Controlling flow The amount of data transferred across a network is limited. Protocols can implement ways of managing data flow to increase throughput andreduce latency. Guaranteeing the order of transmitted data Many networks do not guarantee that the order in which the data is sent will match the order in which it’s received. A protocol can reorder the data to ensure it’s delivered in the correct order. Detecting and correcting errors Many networks are not 100 percent reliable; data can become corrupted. It’s important to detect corruption and, ideally, correct it. Formatting and encoding data Data isn’t always in a format suitable for transmitting on the network. A protocol can specify ways of encoding data, such as encoding English text into binary values.","tags":[],"categories":[{"name":"Network Security","slug":"Network-Security","permalink":"http://aritlh.github.io/categories/Network-Security/"}]},{"title":"VueJS #4 Rendering Lists 1.1","date":"2024-04-16T01:12:21.000Z","path":"wiki/Programming/VueJS/rendering-lists.1.1/","text":"Maintaining State with key​When Vue is updating a list of elements rendered with v-for, by default it uses an “in-place patch” strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values). To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique key attribute for each item: 123&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- content --&gt; &lt;/div&gt; When using &lt;template v-for&gt;, the key should be placed on the &lt;template&gt; container: 123&lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt; &lt;li&gt;{{ todo.name }}&lt;/li&gt; &lt;/template&gt; Note key here is a special attribute being bound with v-bind. It should not be confused with the property key variable when using v-for with an object. It is recommended to provide a key attribute with v-for whenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains. The key binding expects primitive values - i.e. strings and numbers. Do not use objects as v-for keys. For detailed usage of the key attribute, please see the key API documentation. v-for with a Component This section assumes knowledge of Components. Feel free to skip it and come back later. You can directly use v-for on a component, like any normal element (don’t forget to provide a key): 1&lt;MyComponent v-for=&quot;item in items&quot; :key=&quot;item.id&quot; /&gt; However, this won’t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props: 123456&lt;MyComponent v-for=&quot;(item, index) in items&quot; :item=&quot;item&quot; :index=&quot;index&quot; :key=&quot;item.id&quot; /&gt; The reason for not automatically injecting item into the component is because that makes the component tightly coupled to how v-for works. Being explicit about where its data comes from makes the component reusable in other situations.​ Example of a Simple Todo ListThis example of a simple todo list to see how to render a list of components using v-for, passing different data to each instance. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// App.vue &lt;script&gt; import TodoItem from &#39;./TodoItem.vue&#39; export default { components: { TodoItem }, data() { return { newTodoText: &#39;&#39;, todos: [ { id: 1, title: &#39;Do the dishes&#39; }, { id: 2, title: &#39;Take out the trash&#39; }, { id: 3, title: &#39;Mow the lawn&#39; } ], nextTodoId: 4 } }, methods: { addNewTodo() { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = &#39;&#39; } } } &lt;/script&gt; &lt;template&gt; &lt;form v-on:submit.prevent=&quot;addNewTodo&quot;&gt; &lt;label for=&quot;new-todo&quot;&gt;Add a todo&lt;/label&gt; &lt;input v-model=&quot;newTodoText&quot; id=&quot;new-todo&quot; placeholder=&quot;E.g. Feed the cat&quot; /&gt; &lt;button&gt;Add&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; &lt;todo-item v-for=&quot;(todo, index) in todos&quot; :key=&quot;todo.id&quot; :title=&quot;todo.title&quot; @remove=&quot;todos.splice(index, 1)&quot; &gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/template&gt; 123456789101112131415// TodoItem.vue &lt;script&gt; export default { props: [&#39;title&#39;], emits: [&#39;remove&#39;] } &lt;/script&gt; &lt;template&gt; &lt;li&gt; {{ title }} &lt;button @click=&quot;$emit(&#39;remove&#39;)&quot;&gt;Remove&lt;/button&gt; &lt;/li&gt; &lt;/template&gt; Array Change DetectionMutation Methods​Vue is able to detect when a reactive array’s mutation methods are called and trigger necessary updates. These mutation methods are: push() pop() shift() unshift() splice() sort() reverse() Replacing an Array​Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. filter(), concat() and slice(), which do not mutate the original array but always return a new array. When working with non-mutating methods, we should replace the old array with the new one: 1this.items = this.items.filter((item) =&gt; item.message.match(/Foo/)) You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation. Displaying Filtered&#x2F;Sorted Results​Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array. For example: 12345678910data() { return { numbers: [1, 2, 3, 4, 5] } }, computed: { evenNumbers() { return this.numbers.filter(n =&gt; n % 2 === 0) } } 1&lt;li v-for=&quot;n in evenNumbers&quot;&gt;{{ n }}&lt;/li&gt; In situations where computed properties are not feasible (e.g. inside nested v-for loops), you can use a method: 12345678910data() { return { sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]] } }, methods: { even(numbers) { return numbers.filter(number =&gt; number % 2 === 0) } } 123&lt;ul v-for=&quot;numbers in sets&quot;&gt; &lt;li v-for=&quot;n in even(numbers)&quot;&gt;{{ n }}&lt;/li&gt; &lt;/ul&gt; Be careful with reverse() and sort() in a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods: 12- return numbers.reverse() + return [...numbers].reverse()","tags":[],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://aritlh.github.io/categories/Programming/"},{"name":"VueJS","slug":"Programming/VueJS","permalink":"http://aritlh.github.io/categories/Programming/VueJS/"}]},{"title":"VueJS #3 Rendering Lists 1.0","date":"2024-04-16T00:42:21.000Z","path":"wiki/Programming/VueJS/rendering-lists-1.0/","text":"v-forWe can use the v-for directive to render a list of items based on an array. The v-for directive requires a special syntax in the form of item in items, where items is the source data array and item is an alias for the array element being iterated on: 12345data() { return { items: [{ message: &#39;Foo&#39; }, { message: &#39;Bar&#39; }] } } 123&lt;li v-for=&quot;item in items&quot;&gt; {{ item.message }} &lt;/li&gt; Inside the v-for scope, template expressions have access to all parent scope properties. In addition, v-for also supports an optional second alias for the index of the current item: 123456data() { return { parentMessage: &#39;Parent&#39;, items: [{ message: &#39;Foo&#39; }, { message: &#39;Bar&#39; }] } } 123&lt;li v-for=&quot;(item, index) in items&quot;&gt; {{ parentMessage }} - {{ index }} - {{ item.message }} &lt;/li&gt; The variable scoping of v-for is similar to the following JavaScript: 12345678910const parentMessage = &#39;Parent&#39; const items = [ /* ... */ ] items.forEach((item, index) =&gt; { // has access to outer scope `parentMessage` // but `item` and `index` are only available in here console.log(parentMessage, item.message, index) }) Notice how the v-for value matches the function signature of the forEach callback. In fact, you can use destructuring on the v-for item alias similar to destructuring function arguments: 12345678&lt;li v-for=&quot;{ message } in items&quot;&gt; {{ message }} &lt;/li&gt; &lt;!-- with index alias --&gt; &lt;li v-for=&quot;({ message }, index) in items&quot;&gt; {{ message }} {{ index }} &lt;/li&gt; For nested v-for, scoping also works similar to nested functions. Each v-for scope has access to parent scopes: 12345&lt;li v-for=&quot;item in items&quot;&gt; &lt;span v-for=&quot;childItem in item.children&quot;&gt; {{ item.message }} {{ childItem }} &lt;/span&gt; &lt;/li&gt; You can also use of as the delimiter instead of in, so that it is closer to JavaScript’s syntax for iterators: 1&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; v-for with an ObjectYou can also use v-for to iterate through the properties of an object. The iteration order will be based on the result of calling Object.keys() on the object: 123456789data() { return { myObject: { title: &#39;How to do lists in Vue&#39;, author: &#39;Jane Doe&#39;, publishedAt: &#39;2016-04-10&#39; } } } 12345&lt;ul&gt; &lt;li v-for=&quot;value in myObject&quot;&gt; {{ value }} &lt;/li&gt; &lt;/ul&gt; You can also provide a second alias for the property’s name (a.k.a. key): 123&lt;li v-for=&quot;(value, key) in myObject&quot;&gt; {{ key }}: {{ value }} &lt;/li&gt; And another for the index: 123&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt; {{ index }}. {{ key }}: {{ value }} &lt;/li&gt; ​ v-for with a Rangev-for can also take an integer. In this case it will repeat the template that many times, based on a range of 1...n. 1&lt;span v-for=&quot;n in 10&quot;&gt;{{ n }}&lt;/span&gt; Note here n starts with an initial value of 1 instead of 0. v-for on &lt;template&gt;Similar to template v-if, you can also use a &lt;template&gt; tag with v-for to render a block of multiple elements. For example: 123456&lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;{{ item.msg }}&lt;/li&gt; &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; v-for with v-if Note It’s not recommended to use v-if and v-for on the same element due to implicit precedence. Refer to style guide for details. When they exist on the same node, v-if has a higher priority than v-for. That means the v-if condition will not have access to variables from the scope of the v-for: 1234567&lt;!-- This will throw an error because property &quot;todo&quot; is not defined on instance. --&gt; &lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; {{ todo.name }} &lt;/li&gt; This can be fixed by moving v-for to a wrapping &lt;template&gt; tag (which is also more explicit): 12345&lt;template v-for=&quot;todo in todos&quot;&gt; &lt;li v-if=&quot;!todo.isComplete&quot;&gt; {{ todo.name }} &lt;/li&gt; &lt;/template&gt;","tags":[],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://aritlh.github.io/categories/Programming/"},{"name":"VueJS","slug":"Programming/VueJS","permalink":"http://aritlh.github.io/categories/Programming/VueJS/"}]},{"title":"VueJS #2 App Configurations","date":"2024-04-15T21:00:21.000Z","path":"wiki/Programming/VueJS/app-configurations/","text":"Every application instance exposes a config object that contains the configuration settings for that application. You can modify its properties before mounting your application. Application APICreateApp()Creates an application instance. Type 1function createApp(rootComponent: Component, rootProps?: object): App Details The first argument is the root component. The second optional argument is the props to be passed to the root component. Example With inline root component: 12345import { createApp } from &#39;vue&#39; const app = createApp({ /* root component options */ }) With imported component: 1234import { createApp } from &#39;vue&#39; import App from &#39;./App.vue&#39; const app = createApp(App) createSSRApp()​Creates an application instance in SSR Hydration mode. Usage is exactly the same as createApp(). app.mount()​Mounts the application instance in a container element. Type 123interface App { mount(rootContainer: Element | string): ComponentPublicInstance } Details The argument can either be an actual DOM element or a CSS selector (the first matched element will be used). Returns the root component instance. If the component has a template or a render function defined, it will replace any existing DOM nodes inside the container. Otherwise, if the runtime compiler is available, the innerHTML of the container will be used as the template. In SSR hydration mode, it will hydrate the existing DOM nodes inside the container. If there are mismatches, the existing DOM nodes will be morphed to match the expected output. For each app instance, mount() can only be called once. Example 1234import { createApp } from &#39;vue&#39; const app = createApp(/* ... */) app.mount(&#39;#app&#39;) Can also mount to an actual DOM element: 1app.mount(document.body.firstChild) app.unmount()​Unmounts a mounted application instance, triggering the unmount lifecycle hooks for all components in the application’s component tree. Type 123interface App { unmount(): void } app.component()​Registers a global component if passing both a name string and a component definition, or retrieves an already registered one if only the name is passed. Type 1234interface App { component(name: string): Component | undefined component(name: string, component: Component): this } Example 1234567891011import { createApp } from &#39;vue&#39; const app = createApp({}) // register an options object app.component(&#39;my-component&#39;, { /* ... */ }) // retrieve a registered component const MyComponent = app.component(&#39;my-component&#39;) See also Component Registration app.directive()Registers a global custom directive if passing both a name string and a directive definition, or retrieves an already registered one if only the name is passed. Type 1234interface App { directive(name: string): Directive | undefined directive(name: string, directive: Directive): this } Example 1234567891011121314151617import { createApp } from &#39;vue&#39; const app = createApp({ /* ... */ }) // register (object directive) app.directive(&#39;my-directive&#39;, { /* custom directive hooks */ }) // register (function directive shorthand) app.directive(&#39;my-directive&#39;, () =&gt; { /* ... */ }) // retrieve a registered directive const myDirective = app.directive(&#39;my-directive&#39;) See also Custom Directives app.use()​Installs a plugin. Type 123interface App { use(plugin: Plugin, ...options: any[]): this } Details Expects the plugin as the first argument, and optional plugin options as the second argument. The plugin can either be an object with an install() method, or just a function that will be used as the install() method. The options (second argument of app.use()) will be passed along to the plugin’s install() method. When app.use() is called on the same plugin multiple times, the plugin will be installed only once. Example 12345678import { createApp } from &#39;vue&#39; import MyPlugin from &#39;./plugins/MyPlugin&#39; const app = createApp({ /* ... */ }) app.use(MyPlugin) See also Plugins app.mixin()​Applies a global mixin (scoped to the application). A global mixin applies its included options to every component instance in the application. Not Recommended Mixins are supported in Vue 3 mainly for backwards compatibility, due to their widespread use in ecosystem libraries. Use of mixins, especially global mixins, should be avoided in application code. For logic reuse, prefer Composables instead. Type 123interface App { mixin(mixin: ComponentOptions): this } app.provide()​Provide a value that can be injected in all descendant components within the application. Type 123interface App { provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | symbol | string, value: T): this } Details Expects the injection key as the first argument, and the provided value as the second. Returns the application instance itself. Example 12345import { createApp } from &#39;vue&#39; const app = createApp(/* ... */) app.provide(&#39;message&#39;, &#39;hello&#39;) Inside a component in the application: 123456export default { inject: [&#39;message&#39;], created() { console.log(this.message) // &#39;hello&#39; } } See also Provide &#x2F; Inject App-level Provide app.runWithContext() app.runWithContext() 3.3+​Execute a callback with the current app as injection context. Type 123interface App { runWithContext&lt;T&gt;(fn: () =&gt; T): T } Details Expects a callback function and runs the callback immediately. During the synchronous call of the callback, inject() calls are able to look up injections from the values provided by the current app, even when there is no current active component instance. The return value of the callback will also be returned. Example 123456789import { inject } from &#39;vue&#39; app.provide(&#39;id&#39;, 1) const injected = app.runWithContext(() =&gt; { return inject(&#39;id&#39;) }) console.log(injected) // 1 app.version​Provides the version of Vue that the application was created with. This is useful inside plugins, where you might need conditional logic based on different Vue versions. Type 123interface App { version: string } Example Performing a version check inside a plugin: 12345678export default { install(app) { const version = Number(app.version.split(&#39;.&#39;)[0]) if (version &lt; 3) { console.warn(&#39;This plugin requires Vue 3&#39;) } } } See also Global API - version app.config​Every application instance exposes a config object that contains the configuration settings for that application. You can modify its properties (documented below) before mounting your application. 12345import { createApp } from &#39;vue&#39; const app = createApp(/* ... */) console.log(app.config) app.config.errorHandler​Assign a global handler for uncaught errors propagating from within the application. Type 123456789interface AppConfig { errorHandler?: ( err: unknown, instance: ComponentPublicInstance | null, // `info` is a Vue-specific error info, // e.g. which lifecycle hook the error was thrown in info: string ) =&gt; void } Details The error handler receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type. It can capture errors from the following sources: Component renders Event handlers Lifecycle hooks setup() function Watchers Custom directive hooks Transition hooks TIP In production, the 3rd argument (info) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference. Example 123app.config.errorHandler = (err, instance, info) =&gt; { // handle error, e.g. report to a service } app.config.warnHandler​Assign a custom handler for runtime warnings from Vue. Type 1234567interface AppConfig { warnHandler?: ( msg: string, instance: ComponentPublicInstance | null, trace: string ) =&gt; void } Details The warning handler receives the warning message as the first argument, the source component instance as the second argument, and a component trace string as the third. It can be used to filter out specific warnings to reduce console verbosity. All Vue warnings should be addressed during development, so this is only recommended during debug sessions to focus on specific warnings among many, and should be removed once the debugging is done. TIP Warnings only work during development, so this config is ignored in production mode. Example 123app.config.warnHandler = (msg, instance, trace) =&gt; { // `trace` is the component hierarchy trace } app.config.performance​Set this to true to enable component init, compile, render and patch performance tracing in the browser devtool performance&#x2F;timeline panel. Only works in development mode and in browsers that support the performance.mark API. Type: boolean See also Guide - Performance app.config.compilerOptions​Configure runtime compiler options. Values set on this object will be passed to the in-browser template compiler and affect every component in the configured app. Note you can also override these options on a per-component basis using the compilerOptions option. Important This config option is only respected when using the full build (i.e. the standalone vue.js that can compile templates in the browser). If you are using the runtime-only build with a build setup, compiler options must be passed to @vue/compiler-dom via build tool configurations instead. For vue-loader: pass via the compilerOptions loader option. Also see how to configure it in vue-cli. For vite: pass via @vitejs/plugin-vue options. app.config.compilerOptions.isCustomElement​Specifies a check method to recognize native custom elements. Type: (tag: string) =&gt; boolean Details Should return true if the tag should be treated as a native custom element. For a matched tag, Vue will render it as a native element instead of attempting to resolve it as a Vue component. Native HTML and SVG tags don’t need to be matched in this function - Vue’s parser recognizes them automatically. Example 1234// treat all tags starting with &#39;ion-&#39; as custom elements app.config.compilerOptions.isCustomElement = (tag) =&gt; { return tag.startsWith(&#39;ion-&#39;) } See also Vue and Web Components app.config.compilerOptions.whitespace​Adjusts template whitespace handling behavior. Type: &#39;condense&#39; | &#39;preserve&#39; Default: &#39;condense&#39; Details Vue removes &#x2F; condenses whitespace characters in templates to produce more efficient compiled output. The default strategy is “condense”, with the following behavior: Leading &#x2F; ending whitespace characters inside an element are condensed into a single space. Whitespace characters between elements that contain newlines are removed. Consecutive whitespace characters in text nodes are condensed into a single space. Setting this option to &#39;preserve&#39; will disable (2) and (3). Example 1app.config.compilerOptions.whitespace = &#39;preserve&#39; app.config.compilerOptions.delimiters​Adjusts the delimiters used for text interpolation within the template. Type: [string, string] Default: [&#39;&#123;&#123;', '&#125;&#125;&#39;] Details This is typically used to avoid conflicting with server-side frameworks that also use mustache syntax. Example 12// Delimiters changed to ES6 template string style app.config.compilerOptions.delimiters = [&#39;${&#39;, &#39;}&#39;] app.config.compilerOptions.comments​Adjusts treatment of HTML comments in templates. Type: boolean Default: false Details By default, Vue will remove the comments in production. Setting this option to true will force Vue to preserve comments even in production. Comments are always preserved during development. This option is typically used when Vue is used with other libraries that rely on HTML comments. Example 1app.config.compilerOptions.comments = true app.config.globalProperties​An object that can be used to register global properties that can be accessed on any component instance inside the application. Type 123interface AppConfig { globalProperties: Record&lt;string, any&gt; } Details This is a replacement of Vue 2’s Vue.prototype which is no longer present in Vue 3. As with anything global, this should be used sparingly. If a global property conflicts with a component’s own property, the component’s own property will have higher priority. Usage 1app.config.globalProperties.msg = &#39;hello&#39; This makes msg available inside any component template in the application, and also on this of any component instance: 12345export default { mounted() { console.log(this.msg) // &#39;hello&#39; } } See also Guide - Augmenting Global Properties TS app.config.optionMergeStrategies​An object for defining merging strategies for custom component options. Type 12345interface AppConfig { optionMergeStrategies: Record&lt;string, OptionMergeFunction&gt; } type OptionMergeFunction = (to: unknown, from: unknown) =&gt; any Details Some plugins &#x2F; libraries add support for custom component options (by injecting global mixins). These options may require special merging logic when the same option needs to be “merged” from multiple sources (e.g. mixins or component inheritance). A merge strategy function can be registered for a custom option by assigning it on the app.config.optionMergeStrategies object using the option’s name as the key. The merge strategy function receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. Example 12345678910111213141516171819202122const app = createApp({ // option from self msg: &#39;Vue&#39;, // option from a mixin mixins: [ { msg: &#39;Hello &#39; } ], mounted() { // merged options exposed on this.$options console.log(this.$options.msg) } }) // define a custom merge strategy for `msg` app.config.optionMergeStrategies.msg = (parent, child) =&gt; { return (parent || &#39;&#39;) + (child || &#39;&#39;) } app.mount(&#39;#app&#39;) // logs &#39;Hello Vue&#39; See also Component Instance - $options","tags":[],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://aritlh.github.io/categories/Programming/"},{"name":"VueJS","slug":"Programming/VueJS","permalink":"http://aritlh.github.io/categories/Programming/VueJS/"}]},{"title":"VueJS #1 Fundamental Topics","date":"2024-04-15T09:38:54.000Z","path":"wiki/Programming/VueJS/fundamental-topics/","text":"Vue is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS and JavaScript, and provides a declarative and component-based programming model that helps you efficiently develop user interfaces, be it simple or complex. What is Vue?Vue is a JavaScript framework for building interfaces. It buids on top of 3 standards: HTML CSS JavaScript and provides a declarative, component-based programming model that helps you efficiently develop user interfaces of any complexity. Here is a minimal example: 123456789import { createApp } from &#39;vue&#39; createApp({ data() { return { count: 0 } } }).mount(&#39;#app&#39;) 12345&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;count++&quot;&gt; Count is: {{ count }} &lt;/button&gt; &lt;/div&gt; The above example demonstrates the two core features of Vue: Declarative Rendering: extends standard HTML with a template syntax that allows us to declaratively describe HTML output based on JavaScript state. Reactivity: automatically tracks JavaScript state changes and efficiently updates the DOM when changes happen. Prerequisites The rest of the documentation assumes basic familiarity with HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics and then come back! You can check your knowledge level with these overviews for JavaScript, HTML and CSS if needed. Prior experience with other frameworks helps, but is not required. The Progressive FrameworkVue is designed to be flexible and incrementally adoptable. Depending on your use case, Vue can be used in different ways: Enhancing static HTML without a build step Embedding as Web Components on any page Single-Page Application (SPA) Fullstack &#x2F; Server-Side Rendering (SSR) Jamstack &#x2F; Static Site Generation (SSG) Targeting desktop, mobile, WebGL, and even the terminal This is why we call Vue “The Progressive Framework”: it’s a framework that can grow with you and adapt to your needs. Single-File Components​In most build-tool-enabled Vue projects, we author Vue components using an HTML-like file format called Single-File Component (also known as *.vue files, abbreviated as SFC). A Vue SFC, as the name suggests, encapsulates the component’s logic (JavaScript), template (HTML), and styles (CSS) in a single file. Here’s the previous example, written in SFC format: 12345678910111213141516171819&lt;script&gt; export default { data() { return { count: 0 } } } &lt;/script&gt; &lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;Count is: {{ count }}&lt;/button&gt; &lt;/template&gt; &lt;style scoped&gt; button { font-weight: bold; } &lt;/style&gt; API StylesVue components can be authored in two different API styles: Options API and Composition API. Options APIWith Options API, we define a component’s logic using an object of options such as data, methods, and mounted. Properties defined by options are exposed on this inside functions, which points to the component instance: 123456789101112131415161718192021222324252627282930&lt;script&gt; export default { // Properties returned from data() become reactive state // and will be exposed on `this`. data() { return { count: 0 } }, // Methods are functions that mutate state and trigger updates. // They can be bound as event handlers in templates. methods: { increment() { this.count++ } }, // Lifecycle hooks are called at different stages // of a component&#39;s lifecycle. // This function will be called when the component is mounted. mounted() { console.log(`The initial count is ${this.count}.`) } } &lt;/script&gt; &lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: {{ count }}&lt;/button&gt; &lt;/template&gt; Composition APIWith Composition API, we define a component’s logic using imported API functions. In SFCs, Composition API is typically used with &lt;script setup&gt;. The setup attribute is a hint that makes Vue perform compile-time transforms that allow us to use Composition API with less boilerplate. For example, imports and top-level variables &#x2F; functions declared in &lt;script setup&gt; are directly usable in the template. Here is the same component, with the exact same template, but using Composition API and &lt;script setup&gt; instead: 1234567891011121314151617181920&lt;script setup&gt; import { ref, onMounted } from &#39;vue&#39; // reactive state const count = ref(0) // functions that mutate state and trigger updates function increment() { count.value++ } // lifecycle hooks onMounted(() =&gt; { console.log(`The initial count is ${count.value}.`) }) &lt;/script&gt; &lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: {{ count }}&lt;/button&gt; &lt;/template&gt; Which to Choose?The Options API: is centered around the concept of a “component instance” (this as seen in the example), which typically aligns better with a class-based mental model for users coming from OOP language backgrounds. It is also more beginner-friendly by abstracting away the reactivity details and enforcing code organization via option groups. The Composition API: is centered around declaring reactive state variables directly in a function scope and composing state from multiple functions together to handle complexity. It is more free-form and requires an understanding of how reactivity works in Vue to be used effectively. In return, its flexibility enables more powerful patterns for organizing and reusing logic. Both API styles are fully capable of covering common use cases. They are different interfaces powered by the exact same underlying system. In fact, the Options API is implemented on top of the Composition API! The fundamental concepts and knowledge about Vue are shared across the two styles. If you are new to Vue, here’s our general recommendation: For learning purposes, go with the style that looks easier to understand to you. Again, most of the core concepts are shared between the two styles. You can always pick up the other style later. For production use: Go with Options API if you are not using build tools, or plan to use Vue primarily in low-complexity scenarios, e.g. progressive enhancement. Go with Composition API + Single-File Components if you plan to build full applications with Vue. You don’t have to commit to only one style during the learning phase. The rest of the documentation will provide code samples in both styles where applicable, and you can toggle between them at any time using the API Preference switches at the top of the left sidebar.","tags":[],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://aritlh.github.io/categories/Programming/"},{"name":"VueJS","slug":"Programming/VueJS","permalink":"http://aritlh.github.io/categories/Programming/VueJS/"}]},{"title":"Badstore v1.2.3","date":"2019-02-11T21:14:54.000Z","path":"wiki/Hacking Walkthrough/Vulnhub/badstore-v123/","text":"The following is a vulnhub engine search from 2004. While this website may not be completely safe from advanced attacks, it serves as a valuable learning resource for beginners like me to practice identifying and exploiting common and easy-to-find web application vulnerabilities. Boot the machine, then perform host scanning using netdiscover. 1$ sudo netdiscover After obtaining the target IP, perform port scanning using nmap. 1$ sudo nmap -sSC -Pn &lt;IP&gt; nmap: Calls the Nmap program. -sS: Performs a TCP SYNC scan, which is a fast and efficient type of port scan. -C: Enables Nmap’s default script to get more information about the target. -Pn: Ignores host discovery and continues scanning on the given target, regardless of whether the target responds or not. &lt;IP&gt;: The IP address of the target to be scanned So, this command will perform a TCP SYN port scan on &lt;IP&gt; display the version of Nmap in use, enable Nmap default scripts to gather additional information about the target, and will continue the scan without verifying whether the target is responding or not. we also found MySQL service open, Let’s try to access the database using root user. 12345678910111213141516171819202122232425262728293031323334353637... PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 1.3.28 ((Unix) mod_ssl/2.8.15 OpenSSL/0.9.7c) | http-robots.txt: 5 disallowed entries |_/cgi-bin /scanbot /backup /supplier /upload |_http-server-header: Apache/1.3.28 (Unix) mod_ssl/2.8.15 OpenSSL/0.9.7c |_http-title: Welcome to BadStore.net v1.2.3s | http-methods: |_ Potentially risky methods: TRACE 443/tcp open ssl/http Apache httpd 1.3.28 ((Unix) mod_ssl/2.8.15 OpenSSL/0.9.7c) | sslv2: | SSLv2 supported | ciphers: | SSL2_RC4_128_EXPORT40_WITH_MD5 | SSL2_RC4_64_WITH_MD5 | SSL2_DES_192_EDE3_CBC_WITH_MD5 | SSL2_RC2_128_CBC_WITH_MD5 | SSL2_IDEA_128_CBC_WITH_MD5 | SSL2_DES_64_CBC_WITH_MD5 | SSL2_RC4_128_WITH_MD5 |_ SSL2_RC2_128_CBC_EXPORT40_WITH_MD5 | ssl-cert: Subject: commonName=www.badstore.net/organizationName=BadStore.net/stateOrProvinceName=Illinois/countryName=US | Subject Alternative Name: email:root@badstore.net | Not valid before: 2006-05-10T12:52:53 |_Not valid after: 2009-02-02T12:52:53 |_http-server-header: Apache/1.3.28 (Unix) mod_ssl/2.8.15 OpenSSL/0.9.7c |_ssl-date: 2024-02-20T12:53:57+00:00; -1d01h58m15s from scanner time. |_http-title: Welcome to BadStore.net v1.2.3s | http-robots.txt: 5 disallowed entries |_/cgi-bin /scanbot /backup /supplier /upload | http-methods: |_ Potentially risky methods: TRACE 3306/tcp open mysql MySQL 4.1.7-standard | mysql-info: | Protocol: 10 | Version: 4.1.7-standard ... 1$ mysql -h &lt;IP&gt; -u root -p From this exposed Database we are able to obtain:","tags":[],"categories":[{"name":"Hacking Walkthrough","slug":"Hacking-Walkthrough","permalink":"http://aritlh.github.io/categories/Hacking-Walkthrough/"},{"name":"Vulnhub","slug":"Hacking-Walkthrough/Vulnhub","permalink":"http://aritlh.github.io/categories/Hacking-Walkthrough/Vulnhub/"}]},{"title":"Git commit message 基本规范","date":"2019-02-11T21:14:54.000Z","path":"wiki/Technology Development/Git/git-commit-message-basic-specifications/","text":"When using git to commit a version, the commit message is very important, as you need to be able to look back at the commit log and see what was changed each time. When we write this commit message, we should follow a certain structure to help us standardize and clarify our thinking. We generally follow the thoughtbot specification, and here are their instructions 5 Useful Tips For A Better Commit Message. 12345650-character subject line 72-character wrapped longer description. This should answer. * Why was this change necessary? * Why was this change necessary? * How does it address the problem? * How does it address the problem? * Are there any side effects? Include a link to the ticket, if any. Simply put: the first line should be no more than 50 characters. 2. the second line is a blank line the third line begins with a descriptive message, each line should be no more than 72 characters in length, with a serial number and no period at the end the descriptive information starting on the third line is the main description: What changes were made to this submission? What changes have been made to this submission? How is the problem being solved? How does it address the problem? Will it affect anything? After the descriptive message, either leave a blank line and close the issue or give a link to the appropriate ticket. Example: 12345678fix($compile): couple of unit tests for IE9 1. Older IEs serialize html uppercased, but IE9 does not... 2. would be better to expect case insensitive, unfortunately jasmine does 3. not allow to user regexps for throw expectations Closes #392 Breaks foo.bar api, foo.baz should be used instead","tags":[],"categories":[{"name":"Technology Development","slug":"Technology-Development","permalink":"http://aritlh.github.io/categories/Technology-Development/"},{"name":"Git","slug":"Technology-Development/Git","permalink":"http://aritlh.github.io/categories/Technology-Development/Git/"}]},{"title":"Welcome Aritlh's Wiki Site","date":"2017-01-22T21:14:54.000Z","path":"wiki/index/","text":"This is Aritlh’s personal Wiki site, mainly recording some scattered knowledge points summarized from his own words. I’ve always felt that knowledge should not be fragmented, but structured. So I hope to find an elegant way to manage my knowledge. I have learned about or tried methods such as OneNote, Evernote, Blogs, Wikis, etc. and summarized a set of processes for knowledge acquisition, absorption, and management that I think is relatively reasonable: Use web pages, RSS, WeChat, and other online channels as sources of knowledge acquisition. Use a note-taking system (handwritten notes, OneNote, Evernote) to initially filter valuable and targeted information, bookmark information, classify and organize it, and take notes on the key points after reading. For the occasional one or two sentences, or very scattered ideas, inspirations, and initially digested content that come to mind, record them in a Wiki. Finally, when there is a certain amount of content in a section of the Wiki, re-read the notes and content in that section of the Wiki, refine and distill them, add your own thoughts and understanding, and write an article to be published on a blog. In practice, the note-taking system is mainly for classifying and organizing large chunks of information, the Wiki is mainly for accumulating scattered knowledge, and the blog is only for the essence. When a section of the Wiki is first created, there may be very little content or just a sentence. But through this process, as you encounter more and more about that topic, the scattered knowledge also increases, and the content recorded in that section of the Wiki will also increase, which is to structure and organize what was originally a large amount of fragmented knowledge through accumulation. The purpose of the blog is to share and showcase your knowledge and demonstrate your level of expertise. It needs to present something substantial, so it is not suitable for scattered snippets of knowledge. It is more suitable for presenting a series of summaries or tutorials, as a highly systematic knowledge platform. When I tried to deploy my own Wiki system, I started to struggle with choosing which Wiki system to use. Referring to online blogs, I actually deployed and compared several popular Wiki systems: MediaWiki, DokuWiki, MDwiki, TiddlyWiki, wiz, vimwiki, Simiki, Wikitten, etc. None of them were satisfactory. Some were difficult and complex to deploy, some had ugly interfaces, some couldn’t have nested categories, some nested categories couldn’t be expanded, some couldn’t search, and some even didn’t use Markdown… Based on these unsatisfactory user experiences, I summarized some of my requirements for a personal Wiki: Simple and beautiful interface with a friendly font and layout Support for multi-level categorization Easy to modify and update content Simple deployment Category directories can be expanded and collapsed When a category is expanded, you can view the titles of all articles&#x2F;entries under that category Each article&#x2F;entry can be assigned multiple categories&#x2F;tags The Wiki should support internal linking Use Markdown to write articles&#x2F;entries Support full-text search (searchable content and titles) In my previous usage, Wikitten was the closest to my needs, but there were still some conditions that were not met, such as deployment and search. But personally, I liked the style of Wikitten. So in the end, I chose to mimic the style of Wikitten and write this Hexo-based Wiki theme hexo-theme-Wikitten as my own Wiki system, which basically implements the above requirements. Now I’m using it for myself for the time being, of course, this initial functionality is still very simple, and there is a bunch of bugs and TODO lists that need to be maintained. I welcome anyone interested to submit PRs.","tags":[],"categories":[]}],"categories":[{"name":"Programming","slug":"Programming","permalink":"http://aritlh.github.io/categories/Programming/"},{"name":"VueJS","slug":"Programming/VueJS","permalink":"http://aritlh.github.io/categories/Programming/VueJS/"},{"name":"Network Security","slug":"Network-Security","permalink":"http://aritlh.github.io/categories/Network-Security/"},{"name":"Hacking Walkthrough","slug":"Hacking-Walkthrough","permalink":"http://aritlh.github.io/categories/Hacking-Walkthrough/"},{"name":"Vulnhub","slug":"Hacking-Walkthrough/Vulnhub","permalink":"http://aritlh.github.io/categories/Hacking-Walkthrough/Vulnhub/"},{"name":"Technology Development","slug":"Technology-Development","permalink":"http://aritlh.github.io/categories/Technology-Development/"},{"name":"Git","slug":"Technology-Development/Git","permalink":"http://aritlh.github.io/categories/Technology-Development/Git/"}],"tags":[]}